
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Graph Algorithms &#8212; Algorithms Review Guide</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Algorithms Review Guide</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="README.html">
   Algorithms Review Guide
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="tree.html">
   Trees
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hashmap.html">
   HashMap
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sorting_and_searching.html">
   Sorting and Searching
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="dynamic_programming.html">
   Dynamic Programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="number_theory.html">
   Number Theory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="probability.html">
   Probability
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="string_array.html">
   String / Array
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linked_list.html">
   Linked List
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bit_manipulation.html">
   Bit Manipulation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="python.html">
   Python
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/graph.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/peter-lucia/algorithms"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/peter-lucia/algorithms/issues/new?title=Issue%20on%20page%20%2Fgraph.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/peter-lucia/algorithms/gh-pages?urlpath=tree/book/_build/html/graph.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dfs">
   DFS
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dfs-for-a-binary-tree">
     DFS for a binary tree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dfs-for-adjacency-list">
     DFS for Adjacency List
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     DFS for Adjacency List
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#find-and-remove-leaves-in-a-binary-tree-dfs-application">
     Find and remove leaves in a binary tree (DFS application)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#employee-importance-dfs">
   690. Employee Importance (DFS)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#number-of-provinces">
   547. Number of Provinces
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bfs-adjacency-list">
   BFS Adjacency List
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pros-and-cons-of-matrix-representation-vs-adjacency-list-representation-vs-objects-and-pointers-to-represent-graphs">
     Pros and cons of matrix representation vs. adjacency list representation vs. objects and pointers to represent graphs
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#storage">
       Storage
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#adding-a-vertex">
       Adding a vertex
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#removing-an-edge">
       Removing an edge
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#querying-edges">
       Querying edges
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kruskal-s-algorithm">
     Kruskal’s Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dijkstra-s-algorithm">
     Dijkstra’s Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#number-of-islands">
     Number of islands
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shortest-path-in-a-grid-with-obstacles-elimination">
   1293. Shortest Path in a Grid with Obstacles Elimination
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kruskal-s-minimum-spanning-tree-algorithm">
   Kruskal’s Minimum Spanning Tree Algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#prim-s-minimum-spanning-tree-algorithm">
   Prim’s Minimum Spanning Tree Algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#disjoint-set">
   Disjoint Set
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#min-cost-to-connect-all-points-kruskal-prim-s-mst-application">
   1584. Min Cost to Connect All Points (Kruskal / Prim’s MST application)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solution-using-kruskal-s-algorithm-union-find-with-integers">
   Solution using Kruskal’s Algorithm (Union / Find with integers)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solution-kruskal-s-algorithm-union-find-with-points">
   Solution: Kruskal’s Algorithm (Union / Find with points)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-detect-a-cycle-with-dfs">
   How to detect a cycle with DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-detect-a-cycle-using-union-find">
   How to detect a cycle using Union-Find
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#topological-sorting-with-dfs">
   Topological Sorting with DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#floyd-warshall-all-pairs-shortest-path-apsp-problem">
   Floyd Warshall All Pairs Shortest Path (APSP) problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#find-all-bridges-in-an-undirected-graph-with-dfs">
   Find all bridges in an undirected graph with DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#boggle-find-all-possible-words-in-a-board-of-characters-using-dfs">
   Boggle - find all possible words in a board of characters using DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#experiments">
   Experiments
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#longest-increasing-path-in-a-matrix">
     329. Longest Increasing Path in a Matrix
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Graph Algorithms</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dfs">
   DFS
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dfs-for-a-binary-tree">
     DFS for a binary tree
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dfs-for-adjacency-list">
     DFS for Adjacency List
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     DFS for Adjacency List
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#find-and-remove-leaves-in-a-binary-tree-dfs-application">
     Find and remove leaves in a binary tree (DFS application)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#employee-importance-dfs">
   690. Employee Importance (DFS)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#number-of-provinces">
   547. Number of Provinces
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bfs-adjacency-list">
   BFS Adjacency List
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pros-and-cons-of-matrix-representation-vs-adjacency-list-representation-vs-objects-and-pointers-to-represent-graphs">
     Pros and cons of matrix representation vs. adjacency list representation vs. objects and pointers to represent graphs
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#storage">
       Storage
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#adding-a-vertex">
       Adding a vertex
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#removing-an-edge">
       Removing an edge
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#querying-edges">
       Querying edges
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kruskal-s-algorithm">
     Kruskal’s Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dijkstra-s-algorithm">
     Dijkstra’s Algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#number-of-islands">
     Number of islands
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shortest-path-in-a-grid-with-obstacles-elimination">
   1293. Shortest Path in a Grid with Obstacles Elimination
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kruskal-s-minimum-spanning-tree-algorithm">
   Kruskal’s Minimum Spanning Tree Algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#prim-s-minimum-spanning-tree-algorithm">
   Prim’s Minimum Spanning Tree Algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#disjoint-set">
   Disjoint Set
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#min-cost-to-connect-all-points-kruskal-prim-s-mst-application">
   1584. Min Cost to Connect All Points (Kruskal / Prim’s MST application)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solution-using-kruskal-s-algorithm-union-find-with-integers">
   Solution using Kruskal’s Algorithm (Union / Find with integers)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solution-kruskal-s-algorithm-union-find-with-points">
   Solution: Kruskal’s Algorithm (Union / Find with points)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-detect-a-cycle-with-dfs">
   How to detect a cycle with DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-detect-a-cycle-using-union-find">
   How to detect a cycle using Union-Find
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#topological-sorting-with-dfs">
   Topological Sorting with DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#floyd-warshall-all-pairs-shortest-path-apsp-problem">
   Floyd Warshall All Pairs Shortest Path (APSP) problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#find-all-bridges-in-an-undirected-graph-with-dfs">
   Find all bridges in an undirected graph with DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#boggle-find-all-possible-words-in-a-board-of-characters-using-dfs">
   Boggle - find all possible words in a board of characters using DFS
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#experiments">
   Experiments
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#longest-increasing-path-in-a-matrix">
     329. Longest Increasing Path in a Matrix
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="graph-algorithms">
<h1>Graph Algorithms<a class="headerlink" href="#graph-algorithms" title="Permalink to this headline">¶</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
</pre></div>
</div>
</div>
</div>
<section id="dfs">
<h2>DFS<a class="headerlink" href="#dfs" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Retains the path in class variable</p></li>
<li><p>In DFS, you traverse each node exactly once. Therefore, the time complexity of DFS is at least O(V).</p></li>
</ul>
<p>Now, any additional complexity comes from how you discover all the outgoing paths or edges for each node which, in turn, is dependent on the way your graph is implemented. If an edge leads you to a node that has already been traversed, you skip it and check the next. Typical DFS implementations use a hash table to maintain the list of traversed nodes so that you could find out if a node has been encountered before in O(1) time (constant time).</p>
<p>If your graph is implemented as an adjacency matrix (a V x V array), then, for each node, you have to traverse an entire row of length V in the matrix to discover all its outgoing edges. Please note that each row in an adjacency matrix corresponds to a node in the graph, and the said row stores information about edges stemming from the node. So, the complexity of DFS is O(V * V) = O(V^2).</p>
<p>If your graph is implemented using adjacency lists, wherein each node maintains a list of all its adjacent edges, then, for each node, you could discover all its neighbors by traversing its adjacency list just once in linear time. For a directed graph, the sum of the sizes of the adjacency lists of all the nodes is E (total number of edges). So, the complexity of DFS is O(V) + O(E) = O(V + E).</p>
<p>For an undirected graph, each edge will appear twice. Once in the adjacency list of either end of the edge. So, the overall complexity will be O(V) + O (2E) ~ O(V + E).</p>
<p>There are different other ways to implement a graph. You can reason the complexity accordingly.
Source: <a class="reference external" href="https://www.quora.com/Why-is-the-complexity-of-DFS-O-V+E">https://www.quora.com/Why-is-the-complexity-of-DFS-O-V+E</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="mi">1</span>
      <span class="o">/</span>   \
     <span class="mi">2</span>     <span class="mi">3</span>
    <span class="o">/</span> \
   <span class="mi">4</span>   <span class="mi">5</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#### Definition for a binary tree node</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">DFS</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">explored</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">dfs_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># pre-order traversal</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs_traversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs_traversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>


<span class="c1">#                 1</span>
<span class="c1">#               /    \</span>
<span class="c1">#              2      3</span>
<span class="c1">#            /  \</span>
<span class="c1">#           4    5</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="n">dfs</span> <span class="o">=</span> <span class="n">DFS</span><span class="p">()</span>
<span class="n">dfs</span><span class="o">.</span><span class="n">dfs_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Found 1
Found 2
Found 4
Found 5
Found 3
</pre></div>
</div>
</div>
</div>
<section id="dfs-for-a-binary-tree">
<h3>DFS for a binary tree<a class="headerlink" href="#dfs-for-a-binary-tree" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Retains path as parameter</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">explored</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">dfs_traversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">explored</span><span class="p">)</span>
        <span class="n">dfs_traversal</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">explored</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="n">dfs</span> <span class="o">=</span> <span class="n">DFS</span><span class="p">()</span>
<span class="n">explored</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">dfs_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">explored</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">explored</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Found 1
Found 2
Found 4
Found 5
Found 3
[1, 2, 4, 5, 3]
</pre></div>
</div>
</div>
</div>
</section>
<section id="dfs-for-adjacency-list">
<h3>DFS for Adjacency List<a class="headerlink" href="#dfs-for-adjacency-list" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Only retains path by printing it</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>            <span class="n">A</span>
          <span class="o">/</span>   \
         <span class="n">B</span>     <span class="n">C</span>
       <span class="o">/</span>  \   <span class="o">/</span>
      <span class="n">D</span>   <span class="n">E</span>  <span class="n">F</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># https://www.educative.io/edpresso/how-to-implement-depth-first-search-in-python</span>
<span class="c1"># Using a Python dictionary to act as an adjacency list</span>
<span class="c1"># Time complexity: O(V + E)</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;A&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">],</span>
    <span class="s1">&#39;B&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;C&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">],</span>
    <span class="s1">&#39;D&#39;</span> <span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;E&#39;</span> <span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;F&#39;</span> <span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

<span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Set to keep track of visited nodes.</span>
<span class="c1"># Driver Code</span>
<span class="n">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A
B
D
E
C
F
</pre></div>
</div>
</div>
</div>
</section>
<section id="id1">
<h3>DFS for Adjacency List<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Retains the path via the visited array</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

<span class="c1"># Driver Code</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># List to keep track of visited nodes.</span>
<span class="n">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;A&#39;, &#39;B&#39;, &#39;D&#39;, &#39;E&#39;, &#39;C&#39;, &#39;F&#39;]
</pre></div>
</div>
</div>
</div>
</section>
<section id="find-and-remove-leaves-in-a-binary-tree-dfs-application">
<h3>Find and remove leaves in a binary tree (DFS application)<a class="headerlink" href="#find-and-remove-leaves-in-a-binary-tree-dfs-application" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                      <span class="mi">20</span>                       <span class="mi">20</span>               <span class="mi">20</span>        <span class="mi">20</span>
                    <span class="o">/</span>    \                   <span class="o">/</span>    \           <span class="o">/</span>
                  <span class="mi">8</span>       <span class="mi">22</span>               <span class="mi">8</span>       <span class="mi">22</span>       <span class="mi">8</span>
                <span class="o">/</span>   \    <span class="o">/</span>   \              \
              <span class="mi">5</span>      <span class="mi">3</span>  <span class="mi">4</span>    <span class="mi">25</span>               <span class="mi">3</span>
                    <span class="o">/</span> \
                  <span class="mi">10</span>    <span class="mi">14</span>

</pre></div>
</div>
<p>Levels of leaf nodes.</p>
<p>The higher level is found after removing lower level leaves</p>
<ul class="simple">
<li><p>level 0 nodes: 5, 10, 14, 4, 25</p></li>
<li><p>level 1 nodes: 3, 22</p></li>
<li><p>level 2 nodes: 8</p></li>
<li><p>level 3 nodes: 20</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findLeaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Example:</span>
<span class="sd">                      20                       20               20        20</span>
<span class="sd">                    /    \                   /    \           /</span>
<span class="sd">                  8       22               8       22       8</span>
<span class="sd">                /   \    /   \              \</span>
<span class="sd">              5      3  4    25               3</span>
<span class="sd">                    / \</span>
<span class="sd">                  10    14</span>

<span class="sd">        - level 0 nodes: 5, 10, 14, 4, 25</span>
<span class="sd">        - level 1 nodes: 3, 22</span>
<span class="sd">        - level 2 nodes: 8</span>
<span class="sd">        - level 3 nodes: 20</span>
<span class="sd">        Output:</span>
<span class="sd">        {</span>
<span class="sd">            0: [5, 10, 14, 4, 25],</span>
<span class="sd">            1: [3, 22],</span>
<span class="sd">            2: [8],</span>
<span class="sd">            3: [20]</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Gets the maximum depth from the left and right subtrees</span>
<span class="sd">            of a given node</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">level</span>
            <span class="n">max_left_level</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
            <span class="n">max_right_level</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_left_level</span><span class="p">,</span> <span class="n">max_right_level</span><span class="p">)</span>
            <span class="n">lookup</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
        <span class="c1"># lookup.values() for defaultdict returns</span>
        <span class="c1"># a list of lists for all values</span>
        <span class="k">return</span> <span class="n">lookup</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">findLeaves</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(&lt;class &#39;list&#39;&gt;, {0: [5, 10, 14, 4, 25], 1: [3, 22], 2: [8], 3: [20]})
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>dict_values([[5, 10, 14, 4, 25], [3, 22], [8], [20]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">findLeaves</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>defaultdict(&lt;class &#39;list&#39;&gt;, {0: [2, 8], 1: [4], 2: [22], 3: [20]})
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>dict_values([[2, 8], [4], [22], [20]])
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="employee-importance-dfs">
<h2>690. Employee Importance (DFS)<a class="headerlink" href="#employee-importance-dfs" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/employee-importance/">https://leetcode.com/problems/employee-importance/</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definition for Employee.</span>
<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">importance</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">subordinates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">importance</span> <span class="o">=</span> <span class="n">importance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subordinates</span> <span class="o">=</span> <span class="n">subordinates</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getImportance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">employees</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Employee&#39;</span><span class="p">],</span> <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time complexity: O(n) where n is the number of employees</span>
<span class="sd">        Space Complexity: O(n) to hold all employees in the hashmap</span>

<span class="sd">        Approach: DFS</span>
<span class="sd">        1. Find the employee id</span>
<span class="sd">        2. Run DFS on the employee id, summing total importance along the way</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">employees_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">emp</span> <span class="ow">in</span> <span class="n">employees</span><span class="p">:</span>
            <span class="n">employees_map</span><span class="p">[</span><span class="n">emp</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">emp</span>

        <span class="n">desired_employee</span> <span class="o">=</span> <span class="n">employees_map</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">employee</span><span class="p">:</span> <span class="n">Employee</span><span class="p">,</span> <span class="n">total</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">employee</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">employee</span><span class="o">.</span><span class="n">importance</span>

            <span class="k">for</span> <span class="n">sub_id</span> <span class="ow">in</span> <span class="n">employee</span><span class="o">.</span><span class="n">subordinates</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">employees_map</span><span class="p">[</span><span class="n">sub_id</span><span class="p">],</span> <span class="n">total</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>


        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">desired_employee</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">employees</span> <span class="o">=</span> <span class="p">[</span><span class="n">Employee</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Employee</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[]),</span> <span class="n">Employee</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[])]</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">getImportance</span><span class="p">(</span><span class="n">employees</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">11</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="number-of-provinces">
<h2>547. Number of Provinces<a class="headerlink" href="#number-of-provinces" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findCircleNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isConnected</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="c1"># Approach DFS</span>
        <span class="c1"># Run DFS from each vertex if that vertex is not yet visited</span>

        <span class="n">num_vertices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isConnected</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">starting_vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">adj_matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">visited</span><span class="p">:</span> <span class="nb">set</span><span class="p">):</span>

            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">starting_vertex</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">starting_vertex</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adj_matrix</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>


        <span class="n">cc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isConnected</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
                <span class="n">cc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">cc</span>
<span class="n">circle</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">]</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">findCircleNum</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
<span class="n">circle</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">]</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">findCircleNum</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="bfs-adjacency-list">
<h2>BFS Adjacency List<a class="headerlink" href="#bfs-adjacency-list" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Source: https://www.educative.io/edpresso/how-to-implement-a-breadth-first-search-in-python</span>
<span class="c1"># Time complexity: O(V + E)</span>
<span class="c1">#                     A - C</span>
<span class="c1">#                    / \ /</span>
<span class="c1">#                   B   F</span>
<span class="c1">#                 / \  /</span>
<span class="c1">#                D   E</span>

<span class="c1"># this is a directed graph</span>
<span class="n">my_graph</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;A&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">],</span>
  <span class="s1">&#39;B&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
  <span class="s1">&#39;C&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">],</span>
  <span class="s1">&#39;D&#39;</span> <span class="p">:</span> <span class="p">[],</span>
  <span class="s1">&#39;E&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">],</span>
  <span class="s1">&#39;F&#39;</span> <span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">graph</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Visiting vertices: &quot;</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># print(&quot;Queue: &quot;, queue)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>

<span class="c1"># Driver Code</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># List to keep track of visited nodes.</span>
<span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">bfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">my_graph</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Visited: &quot;</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Visiting vertices: 
A B F C D E 
Visited:  [&#39;A&#39;, &#39;B&#39;, &#39;F&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]
</pre></div>
</div>
</div>
</div>
<section id="pros-and-cons-of-matrix-representation-vs-adjacency-list-representation-vs-objects-and-pointers-to-represent-graphs">
<h3>Pros and cons of matrix representation vs. adjacency list representation vs. objects and pointers to represent graphs<a class="headerlink" href="#pros-and-cons-of-matrix-representation-vs-adjacency-list-representation-vs-objects-and-pointers-to-represent-graphs" title="Permalink to this headline">¶</a></h3>
<p>Sources:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.section.io/engineering-education/graph-data-structure-python/">https://www.section.io/engineering-education/graph-data-structure-python/</a></p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/comparison-between-adjacency-list-and-adjacency-matrix-representation-of-graph/">https://www.geeksforgeeks.org/comparison-between-adjacency-list-and-adjacency-matrix-representation-of-graph/</a></p></li>
<li><p><a class="reference external" href="https://www.bigocheatsheet.com">https://www.bigocheatsheet.com</a></p></li>
</ul>
<p>Matrix representation (a.k.a adjacency matrix)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span>
<span class="n">A</span> <span class="mi">0</span> <span class="mi">4</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="n">B</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="n">C</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="n">D</span> <span class="mi">3</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="n">E</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Adjacency List representation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">B</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">B</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">C</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">C</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">D</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Note: In a complete graph where every vertex is connected, every entry in the matrix would have a value,
so iterating over all of them takes <span class="math notranslate nohighlight">\(O(|E|) = O(|V|^2)\)</span> time.</p>
<section id="storage">
<h4>Storage<a class="headerlink" href="#storage" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Matrix representation requires <span class="math notranslate nohighlight">\(O(|V|^2)\)</span> space since a VxV matrix is used to map connections. Wasted space for unused connections</p></li>
<li><p>Adjacency list requires <span class="math notranslate nohighlight">\(O(|V| + |E|)\)</span> space since a O(|E|) is required for storing neighbors corresponding to each vertex</p></li>
<li><p>Objects and pointers requires <span class="math notranslate nohighlight">\(O(|V| + |E|)\)</span> space</p></li>
</ul>
</section>
<section id="adding-a-vertex">
<h4>Adding a vertex<a class="headerlink" href="#adding-a-vertex" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Matrix representation requires the storage be increased to <span class="math notranslate nohighlight">\(O((|V|+1)^2)\)</span>. To do this we need to copy the whole matrix</p></li>
<li><p>Adjacency list requires O(1) time on average. Hash table insertion requires O(n) time in the worst though if there are too many collisions.</p></li>
<li><p>Objects and pointers requires O(1) time since we’d just update or add a pointer to a Node object</p></li>
</ul>
</section>
<section id="removing-an-edge">
<h4>Removing an edge<a class="headerlink" href="#removing-an-edge" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Matrix representation takes O(1) time since we set matrix[i][j] = 0</p></li>
<li><p>Adjacency list representation requires potentially traversing over all edges in the worst case so it’s O(|E|) time</p></li>
<li><p>Removing an edge requires O(1) time for objects and pointers since we just update or remove a pointer in a Node object</p></li>
</ul>
</section>
<section id="querying-edges">
<h4>Querying edges<a class="headerlink" href="#querying-edges" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Matrix representation requires O(1) time always.</p></li>
<li><p>Adjacency List requires <span class="math notranslate nohighlight">\(O(|V|)\)</span> time since a vertex can have at most <span class="math notranslate nohighlight">\(O(|V|)\)</span> neighbors, so we’d have to check every adjacency vertex.</p></li>
</ul>
</section>
</section>
<section id="kruskal-s-algorithm">
<h3>Kruskal’s Algorithm<a class="headerlink" href="#kruskal-s-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Kruskal’s algorithm finds a minimum spanning forest of an undirected edge-weighted graph. If the graph is connected, it finds a minimum spanning tree.</p>
</section>
<section id="dijkstra-s-algorithm">
<h3>Dijkstra’s Algorithm<a class="headerlink" href="#dijkstra-s-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Time Complexity: <span class="math notranslate nohighlight">\(O((|V| + |E|)log(|V|))\)</span></p>
<p>Dijkstra’s Algorithm finds the shortest path from a starting node to all other nodes of a graph</p>
<ul class="simple">
<li><p>By default, all nodes are assumed to be inf distance away from the starting node, u</p></li>
<li><p>We then traverse in BFS fashion (by levels) from the starting node outward until we reach all nodes</p></li>
<li><p>When a new node v’, is visited from v, we add dist(u,v) + dist(v, v’)</p></li>
<li><p>If a node v’ has already been visited from v,
we set dist(u, v’) = min(dist(u,v’), dist(u,v) + dist(v, v’)</p></li>
<li><p>We repeat until all nodes have been visited since this implies all edges have been traversed</p></li>
<li><p>Dijkstra’s algorithm does not work with negative edges</p></li>
</ul>
<p>Sources:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.analyticssteps.com/blogs/dijkstras-algorithm-shortest-path-algorithm">https://www.analyticssteps.com/blogs/dijkstras-algorithm-shortest-path-algorithm</a></p></li>
<li><p><a class="reference external" href="https://www.techiedelight.com/single-source-shortest-paths-dijkstras-algorithm/">https://www.techiedelight.com/single-source-shortest-paths-dijkstras-algorithm/</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heappush</span>

<span class="c1"># Stores the heap node</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="c1"># Override the __lt__() function to make `Node` class work with a min-heap</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">weight</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dijkstra&#39;s algorithm does not handle negative weight edges.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dest</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">count_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>



<span class="k">def</span> <span class="nf">get_route</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">route</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">get_route</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">route</span><span class="p">)</span>
        <span class="n">route</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


<span class="c1"># Run Dijkstra’s algorithm on a given graph</span>
<span class="k">def</span> <span class="nf">find_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

    <span class="c1"># create a min-heap and push source node having distance 0</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>

    <span class="c1"># set initial distance from the source to `v` as infinity</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># distance from the source to itself is zero</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># list to track vertices for which minimum cost is already found</span>
    <span class="n">done</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">done</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># stores predecessor of a vertex (to a print path)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># run till min-heap is empty</span>
    <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span> <span class="c1"># Remove and return the best vertex</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">vertex</span> <span class="c1"># get the vertex number</span>

        <span class="c1"># do for each neighbor `v` of `u`</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span>
                <span class="n">prev</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span>

        <span class="c1"># mark vertex u as done so it will not get picked up again</span>
        <span class="n">done</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">source</span> <span class="ow">and</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="n">get_route</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Path (</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s1"> —&gt; </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">): Minimum cost = </span><span class="si">{</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">, Route = </span><span class="si">{</span><span class="n">route</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">route</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1"># initialize edges as per the above diagram</span>
    <span class="c1"># (u, v, w) represent edge from vertex u to vertex v having weight w</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
            <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="c1">#      1 - 2</span>
    <span class="c1">#     / \ / \</span>
    <span class="c1">#    0 - 4 - 3</span>
    <span class="c1">#</span>
    <span class="c1"># total number of nodes in the graph (labelled from 0 to 4)</span>

    <span class="c1"># construct graph</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">count_vertices</span><span class="p">()</span>

    <span class="c1"># run the Dijkstra’s algorithm from every node</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">find_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Path (0 —&gt; 1): Minimum cost = 4, Route = [0, 4, 1]
Path (0 —&gt; 2): Minimum cost = 6, Route = [0, 4, 1, 2]
Path (0 —&gt; 3): Minimum cost = 5, Route = [0, 4, 3]
Path (0 —&gt; 4): Minimum cost = 3, Route = [0, 4]
Path (1 —&gt; 2): Minimum cost = 2, Route = [1, 2]
Path (1 —&gt; 3): Minimum cost = 6, Route = [1, 4, 3]
Path (1 —&gt; 4): Minimum cost = 4, Route = [1, 4]
Path (2 —&gt; 3): Minimum cost = 9, Route = [2, 3]
Path (3 —&gt; 2): Minimum cost = 7, Route = [3, 2]
Path (4 —&gt; 1): Minimum cost = 1, Route = [4, 1]
Path (4 —&gt; 2): Minimum cost = 3, Route = [4, 1, 2]
Path (4 —&gt; 3): Minimum cost = 2, Route = [4, 3]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dijkstrasAlgorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># dijkstra&#39;s algorithm to find shortest path between top left position in grid to bottom right...</span>

        <span class="n">pq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># tracks shortest distance from source to vertex &#39;v&#39;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># tracks parent of &#39;v&#39; in shortest path from source</span>
        <span class="n">done</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># tracks vertices for which cost is already found</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="c1"># set initial distance from source to &#39;v&#39; as infinity</span>
                <span class="n">dist</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
                <span class="c1"># initialize predecessor of each vertex as nonexistent</span>
                <span class="n">prev</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">done</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># set initial distance from source to itself as 0</span>
        <span class="n">dist</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">done</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">WEIGHT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># same for all edges</span>
        <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
            <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>

            <span class="c1"># for each neighbor</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">),</span> <span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">),</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="k">if</span> <span class="n">iii</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">jjj</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">iii</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">jjj</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">iii</span><span class="p">][</span><span class="n">jjj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">[(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">)]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dist</span><span class="p">[(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)]</span> <span class="o">+</span> <span class="n">WEIGHT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">)]:</span>
                    <span class="n">dist</span><span class="p">[(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)]</span> <span class="o">+</span> <span class="n">WEIGHT</span>
                    <span class="n">prev</span><span class="p">[(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span>
                    <span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">))</span>
            <span class="n">done</span><span class="p">[(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">dist</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">==</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">dist</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">dijkstrasAlgorithm</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># visit each neighbor</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">),</span> <span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">),</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">)]:</span>
                <span class="k">if</span> <span class="n">iii</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">jjj</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">iii</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">jjj</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">iii</span><span class="p">][</span><span class="n">jjj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">new_path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="n">new_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">))</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">iii</span><span class="p">,</span> <span class="n">jjj</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shortest path = &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">new_path</span><span class="p">)</span>
                    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>


            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">))</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Shortest path =  (0, 0) (0, 1) (0, 2) (1, 2) (2, 2) (2, 1) (2, 0) (3, 0) (4, 0) (4, 1) (4, 2)
</pre></div>
</div>
</div>
</div>
</section>
<section id="number-of-islands">
<h3>Number of islands<a class="headerlink" href="#number-of-islands" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/number-of-islands/discuss/56340/Python-Simple-DFS-Solution">https://leetcode.com/problems/number-of-islands/discuss/56340/Python-Simple-DFS-Solution</a></p>
<p>Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands.</p>
<p>An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># DFS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;1&#39;</span> <span class="ow">or</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">return</span>

            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>

        <span class="n">num_islands</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
                    <span class="n">num_islands</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_islands</span>

<span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">]</span>
<span class="p">]</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">numIslands</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">]</span>
<span class="p">]</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">numIslands</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="shortest-path-in-a-grid-with-obstacles-elimination">
<h2>1293. Shortest Path in a Grid with Obstacles Elimination<a class="headerlink" href="#shortest-path-in-a-grid-with-obstacles-elimination" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/">https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">shortestPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="c1"># Use BFS</span>
        <span class="c1"># add state (i, j, k) to queue</span>
        <span class="c1"># keep track of visited states</span>
        <span class="c1"># don&#39;t visit nodes with state k &lt;= 0</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)])</span>

        <span class="c1"># get manhattan distance</span>
        <span class="c1"># if manhattan distance &lt;= k, return it</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_k</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shortest path: &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">new_k</span> <span class="o">=</span> <span class="n">_k</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">new_k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_k</span> <span class="o">=</span> <span class="n">_k</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">new_path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

                    <span class="n">new_path</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_k</span><span class="p">))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_k</span><span class="p">))</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># 0 0 0</span>
<span class="c1"># 1 1 0</span>
<span class="c1"># 0 0 0</span>
<span class="c1"># 0 1 1</span>
<span class="c1"># 0 0 0</span>

<span class="c1"># k = 1</span>

<span class="c1"># fastest route is to go down from top left and then right at the last row.</span>
<span class="c1"># this is equivalent to going right at the top row and then down on the last column</span>
<span class="k">assert</span> <span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">shortestPath</span><span class="p">(</span><span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Shortest path:  (0, 0, 1) (1, 0, 0) (2, 0, 0) (3, 0, 0) (4, 0, 0) (4, 1, 0) (4, 2, 0)
</pre></div>
</div>
</div>
</div>
</section>
<section id="kruskal-s-minimum-spanning-tree-algorithm">
<h2>Kruskal’s Minimum Spanning Tree Algorithm<a class="headerlink" href="#kruskal-s-minimum-spanning-tree-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Source: <a class="reference external" href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/</a></p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal’s MST algorithm on wikipedia</a></p>
<ol class="simple">
<li><p>Sort the edges of the graph by weight, increasing from lowest to highest</p></li>
<li><p>Select the lowest edge available that does not form a cycle</p></li>
<li><p>Repeat step 2 until all edges have been checked.</p></li>
</ol>
<p>Time complexity: <span class="math notranslate nohighlight">\(O(|E|log(|V|))\)</span> -&gt; More optimal for sparse graphs</p>
</section>
<section id="prim-s-minimum-spanning-tree-algorithm">
<h2>Prim’s Minimum Spanning Tree Algorithm<a class="headerlink" href="#prim-s-minimum-spanning-tree-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Source: <a class="reference external" href="https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/">https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim’s algorithm from Wikipedia</a>
Prim’s algorithm (also known as Jarník’s algorithm) is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. The algorithm operates by building this tree one vertex at a time, from an arbitrary starting vertex, at each step adding the cheapest possible connection from the tree to another vertex.</p>
<p>Time complexity:</p>
<p>Adjacency matrix: <span class="math notranslate nohighlight">\( O(|V|^2)\)</span>
Binary Heap and Adjacency List: <span class="math notranslate nohighlight">\(O((|V| + |E|)log(|V|)) = O(|E|log(|V|))\)</span>
Fibonacci Heap and Adjacency List: <span class="math notranslate nohighlight">\(O(|E| + |V|log(|V|) \)</span> -&gt; More optimal for dense graphs</p>
</section>
<section id="disjoint-set">
<h2>Disjoint Set<a class="headerlink" href="#disjoint-set" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">:</span>
   <span class="n">a</span>              <span class="n">d</span>                      <span class="n">a</span>                <span class="n">d</span>
  <span class="o">/</span> \            <span class="o">/</span>    <span class="o">-&gt;</span>              <span class="o">/</span>  <span class="o">|</span>  \    <span class="ow">or</span>    <span class="o">/</span>  <span class="o">|</span>
 <span class="n">b</span>   <span class="n">c</span>          <span class="n">e</span>                    <span class="n">b</span>   <span class="n">c</span>   <span class="n">d</span>        <span class="n">e</span>   <span class="n">a</span>
                                            <span class="o">/</span>           <span class="o">/</span> <span class="o">|</span> \
                                           <span class="n">e</span>           <span class="n">b</span>  <span class="n">c</span>  <span class="n">d</span>
                                <span class="n">rank</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>      <span class="n">rank</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>Useful: <a class="reference external" href="https://www.techiedelight.com/disjoint-set-data-structure-union-find-algorithm/">https://www.techiedelight.com/disjoint-set-data-structure-union-find-algorithm/</a>
Time complexity: O(log|V|) in the worst case where |V| is the number of elements. the running time is bounded by the tree height.
Space complexity: O(|V|) to store parents and rank for each vertex</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the root of x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">root_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">root_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_y</span>
            <span class="c1"># make root_y have the higher rank if they are equal</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">dj_set</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">dj_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># root of 2 and 3 will be 3 since we choose y arbitrarily when ranks are equal</span>
<span class="n">dj_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># root of 3 and 4 will be 3 since 3 has a higher rank from previous operation</span>
<span class="n">dj_set</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># get the root of 4, it should be 3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
</section>
<section id="min-cost-to-connect-all-points-kruskal-prim-s-mst-application">
<h2>1584. Min Cost to Connect All Points (Kruskal / Prim’s MST application)<a class="headerlink" href="#min-cost-to-connect-all-points-kruskal-prim-s-mst-application" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/min-cost-to-connect-all-points/">https://leetcode.com/problems/min-cost-to-connect-all-points/</a></p>
<p>You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].</p>
<p>The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</p>
<p>Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.</p>
</section>
<section id="solution-using-kruskal-s-algorithm-union-find-with-integers">
<h2>Solution using Kruskal’s Algorithm (Union / Find with integers)<a class="headerlink" href="#solution-using-kruskal-s-algorithm-union-find-with-integers" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helpful: https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/1620452/Python-Kruskal&#39;s-%2B-Disjoint-set-Union</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># Initially the rank (height of tree) for each node is zero</span>
        <span class="c1"># since all nodes are separated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="c1"># Map the node (index) to its parent node.</span>
        <span class="c1"># Initially all nodes are separated, so the parent is itself</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the root of x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges nodes x and y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">root_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_y</span>
            <span class="c1"># make root_y have the higher rank if they are equal</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">minCostConnectPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># build a complete graph connecting all points</span>
        <span class="c1"># find the MST</span>

        <span class="c1"># Build list of edges connecting all points</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
                <span class="c1"># since all points are distince, we use the points index in points as its unique identifier</span>
                <span class="c1"># This is easier to work with in the disjoint set structure</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

        <span class="c1"># Kruskal&#39;s algorithm</span>
        <span class="c1"># Initially all points are disconnected</span>
        <span class="n">dj_set</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
        <span class="c1"># sort edges in place by weight, increasing</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">edges_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_edges</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dj_set</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dj_set</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="n">edges_sum</span> <span class="o">+=</span> <span class="n">weight</span>
                <span class="n">dj_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">num_edges</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num_edges</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We&#39;ve built the MST already</span>
                <span class="k">return</span> <span class="n">edges_sum</span>

        <span class="k">return</span> <span class="n">edges_sum</span>
<span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">minCostConnectPoints</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>20
</pre></div>
</div>
</div>
</div>
</section>
<section id="solution-kruskal-s-algorithm-union-find-with-points">
<h2>Solution: Kruskal’s Algorithm (Union / Find with points)<a class="headerlink" href="#solution-kruskal-s-algorithm-union-find-with-points" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># Initially the rank (height of tree) for each node is zero</span>
        <span class="c1"># since all nodes are separated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Map the node (index) to its parent node.</span>
        <span class="c1"># Initially all nodes are separated, so the parent is itself</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the root node of x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges sets that x and y reside in</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">root_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_y</span>
            <span class="c1"># make root_y have the higher rank if they are equal</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">minCostConnectPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># build a complete graph connecting all points</span>
        <span class="c1"># find the MST</span>

        <span class="c1"># Build list of edges connecting all points</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">point1</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point2</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">point1</span> <span class="o">==</span> <span class="n">point2</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">point1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">point1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">point2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="n">point2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
                <span class="c1"># since all points are distinct, we use the points index in points as its unique identifier</span>
                <span class="c1"># This is easier to work with in the disjoint set structure</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">point1</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">point2</span><span class="p">),</span> <span class="n">weight</span><span class="p">))</span>

        <span class="c1"># Kruskal&#39;s algorithm</span>
        <span class="c1"># Initially all points are disconnected</span>
        <span class="n">dj_set</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># sort edges in place by weight, increasing</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">edges_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_edges</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dj_set</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dj_set</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="n">edges_sum</span> <span class="o">+=</span> <span class="n">weight</span>
                <span class="n">dj_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">num_edges</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num_edges</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We&#39;ve built the MST already</span>
                <span class="k">return</span> <span class="n">edges_sum</span>

        <span class="k">return</span> <span class="n">edges_sum</span>
<span class="n">Solution</span><span class="p">()</span><span class="o">.</span><span class="n">minCostConnectPoints</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>20
</pre></div>
</div>
</div>
</div>
</section>
<section id="how-to-detect-a-cycle-with-dfs">
<h2>How to detect a cycle with DFS<a class="headerlink" href="#how-to-detect-a-cycle-with-dfs" title="Permalink to this headline">¶</a></h2>
<p>Time complexity: <span class="math notranslate nohighlight">\(O(|V| + |E|)\)</span> since we do a DFS traversal on a graph represented w/ adjacency list
Space complexity: <span class="math notranslate nohighlight">\(O(|V|)\)</span> to store the visited array
Source: <a class="reference external" href="https://www.geeksforgeeks.org/detect-cycle-undirected-graph/">https://www.geeksforgeeks.org/detect-cycle-undirected-graph/</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># adj. list</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># It&#39;s important to add an edge both ways for an undirected graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">dfs_has_cycle</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

            <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># recursively visit neighbors</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">found_cycle</span> <span class="o">=</span> <span class="n">dfs_has_cycle</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">found_cycle</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">w</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="c1"># start the check at every node since graph may be disconnected</span>
        <span class="c1"># set parent = -1</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">dfs_has_cycle</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph contains cycle&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph does not contain cycle &quot;</span><span class="p">)</span>
<span class="n">g1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>


<span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph contains cycle&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph does not contain cycle &quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Graph contains cycle
Graph does not contain cycle 
</pre></div>
</div>
</div>
</div>
</section>
<section id="how-to-detect-a-cycle-using-union-find">
<h2>How to detect a cycle using Union-Find<a class="headerlink" href="#how-to-detect-a-cycle-using-union-find" title="Permalink to this headline">¶</a></h2>
<p>Time complexity: <span class="math notranslate nohighlight">\(O(|V|log(|V|))\)</span> since the union and find operations take O(log|V|), since the whole tree may need to be traversed
Space complexity: <span class="math notranslate nohighlight">\(O(|V|)\)</span> to hold the disjoint set
Source: <a class="reference external" href="https://www.techiedelight.com/union-find-algorithm-cycle-detection-graph/">https://www.techiedelight.com/union-find-algorithm-cycle-detection-graph/</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># Initially the rank (height of tree) for each node is zero</span>
        <span class="c1"># since all nodes are separated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="c1"># Map the node (index) to its parent node.</span>
        <span class="c1"># Initially all nodes are separated, so the parent is itself</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the root of x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges nodes x and y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">root_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_y</span>
            <span class="c1"># make root_y have the higher rank if they are equal</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># adj. list</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="n">root_u</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">root_v</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root_u</span> <span class="o">==</span> <span class="n">root_v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph contains cycle&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph does not contain cycle &quot;</span><span class="p">)</span>
<span class="n">g1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph contains cycle&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph does not contain cycle &quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Graph contains cycle
Graph does not contain cycle 
</pre></div>
</div>
</div>
</div>
</section>
<section id="topological-sorting-with-dfs">
<h2>Topological Sorting with DFS<a class="headerlink" href="#topological-sorting-with-dfs" title="Permalink to this headline">¶</a></h2>
<p>Topological sorting is a linear ordering of vertices such that for every directed edge (u,v), vertex u comes before v in the ordering.
Topological sorting is not possible if the graph is not a directed acyclic graph (DAG).
There can be more than one topological sorting for a single graph.</p>
<p>Time complexity: O(|V| + |E|)
Space Complexity: O(|V|)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># adj. list</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">topo_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">topo_sort_dfs</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            1. Visited vertex v</span>
<span class="sd">            2. Recursively visited unvisited neighbors of vertex v</span>
<span class="sd">            3. Add v to the stack after its neighbors have been added to the stack</span>
<span class="sd">            Note that the resultant stack will need to be reversed at the end</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                    <span class="n">topo_sort_dfs</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># start the check at every node since graph may be disconnected</span>
        <span class="c1"># set parent = -1</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="n">topo_sort_dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stack</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Driver Code</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The following is a Topological Sort of the given graph&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

<span class="c1"># Function Call</span>
<span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">topo_sort</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Note that [4,5,2,3,1,0] is another valid topological sorting for this graph.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The following is a Topological Sort of the given graph [5, 4, 2, 3, 1, 0]
Note that [4,5,2,3,1,0] is another valid topological sorting for this graph.
</pre></div>
</div>
</div>
</div>
</section>
<section id="floyd-warshall-all-pairs-shortest-path-apsp-problem">
<h2>Floyd Warshall All Pairs Shortest Path (APSP) problem<a class="headerlink" href="#floyd-warshall-all-pairs-shortest-path-apsp-problem" title="Permalink to this headline">¶</a></h2>
<p>Finds the shortest distances between every pair of vertices in a given edge weighted directed graph
Time Complexity: <span class="math notranslate nohighlight">\(O(|V|^3)\)</span>
Space Complexity: <span class="math notranslate nohighlight">\(O(|V|^2)\)</span> Since an adjacency matrix is used</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">floyd_warshall</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the All Pairs Shortest Path (APSP) problem</span>

<span class="sd">    :param graph:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">graph</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dist</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span>           <span class="mi">0</span><span class="p">,</span>            <span class="mi">5</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>           <span class="mi">10</span><span class="p">],</span>
    <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>            <span class="mi">0</span><span class="p">,</span>            <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)],</span>
    <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>            <span class="mi">0</span><span class="p">,</span>            <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>             <span class="mi">0</span><span class="p">]</span>
 <span class="p">]</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">floyd_warshall</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 5, 8, 9]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[inf, 0, 3, 4]
[inf, inf, 0, 1]
[inf, inf, inf, 0]
</pre></div>
</div>
</div>
</div>
</section>
<section id="find-all-bridges-in-an-undirected-graph-with-dfs">
<h2>Find all bridges in an undirected graph with DFS<a class="headerlink" href="#find-all-bridges-in-an-undirected-graph-with-dfs" title="Permalink to this headline">¶</a></h2>
<p>An edge in an undirected graph is a bridge iff removing it disconnects the graph
Time Complexity: <span class="math notranslate nohighlight">\(O(|V| + |E|)\)</span>
Space Complexity: <span class="math notranslate nohighlight">\(O(|V|)\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># adj. list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bridges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># It&#39;s important to add an edge both ways for an undirected graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">print_bridges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bridges</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2"> is a bridge.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_bridge_dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parent</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">low</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">disc</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1. An edge (u,v) where u is a parent of v, is a bridge if there does not</span>
<span class="sd">           exist any other alternative to reach u or an ancestor of u from the</span>
<span class="sd">           subtree rooted with v.</span>
<span class="sd">        2. low[v] indicates the earliest visited vertex reachable from the subtree</span>
<span class="sd">           rooted with v. Therefore, the condition for an edge (u,v) to be a bridge</span>
<span class="sd">           is low[v] &gt; disc[u]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span>
        <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span>  <span class="c1"># earliest visited vertex reachable from subtree rooted with u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">find_bridge_dfs</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span>

                <span class="c1"># since we performed dfs on w, we make sure the earliest ancestor reachable</span>
                <span class="c1"># from v incorporates those reachable from w</span>
                <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>

                <span class="c1"># if the earliest ancestor reachable from the subtree under w</span>
                <span class="c1"># is greater when we discovered v, then v-w is a bridge</span>
                <span class="k">if</span> <span class="n">low</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bridges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="c1"># since w is not a parent of v, make sure the earliest ancestor reachable</span>
                <span class="c1"># from v incorporates the discovery time of w</span>
                <span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">disc</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">find_bridge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="c1"># start the check at every node since graph may be disconnected</span>
        <span class="c1"># set parent = -1</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">find_bridge_dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span>

<span class="c1"># Create a graph given in the above diagram</span>
<span class="n">g1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bridges in first graph &quot;</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">find_bridge</span><span class="p">()</span>
<span class="n">g1</span><span class="o">.</span><span class="n">print_bridges</span><span class="p">()</span>

<span class="n">g2</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">g2</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g2</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g2</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bridges in second graph &quot;</span><span class="p">)</span>
<span class="n">g2</span><span class="o">.</span><span class="n">find_bridge</span><span class="p">()</span>
<span class="n">g2</span><span class="o">.</span><span class="n">print_bridges</span><span class="p">()</span>


<span class="n">g3</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bridges in third graph &quot;</span><span class="p">)</span>
<span class="n">g3</span><span class="o">.</span><span class="n">find_bridge</span><span class="p">()</span>
<span class="n">g3</span><span class="o">.</span><span class="n">print_bridges</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Bridges in first graph 
3-4 is a bridge.
0-3 is a bridge.

Bridges in second graph 
2-3 is a bridge.
1-2 is a bridge.
0-1 is a bridge.

Bridges in third graph 
1-6 is a bridge.
</pre></div>
</div>
</div>
</div>
</section>
<section id="boggle-find-all-possible-words-in-a-board-of-characters-using-dfs">
<h2>Boggle - find all possible words in a board of characters using DFS<a class="headerlink" href="#boggle-find-all-possible-words-in-a-board-of-characters-using-dfs" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://leetcode.com/problems/word-search-ii/">https://leetcode.com/problems/word-search-ii/</a></p>
<p>Approach:</p>
<ul class="simple">
<li><p>Consider every character as a starting character and find all words starting with it.</p></li>
<li><p>All words starting from a character can be found using DFS.</p></li>
</ul>
<p>Time complexity: <span class="math notranslate nohighlight">\(O(m^2 \cdot n^2)\)</span> for board with size m x n since we potentially visit every other location in the board once via DFS for each letter in the board
Space complexity: <span class="math notranslate nohighlight">\(O(mn)\)</span> to store visited state for each element in the board</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dictionary</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;GEEKS&quot;</span><span class="p">,</span> <span class="s2">&quot;FOR&quot;</span><span class="p">,</span> <span class="s2">&quot;QUIZ&quot;</span><span class="p">,</span> <span class="s2">&quot;GO&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">find_words_dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">current_word</span><span class="p">):</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">current_word</span> <span class="o">+=</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">current_word</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found: </span><span class="si">{</span><span class="n">current_word</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># traverse the 8 adjacent cells around board[i][j]</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>  <span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>             <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span> <span class="ow">and</span>
                <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">find_words_dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">current_word</span><span class="p">)</span>

    <span class="c1"># make last character the next starting character</span>
    <span class="n">current_word</span> <span class="o">=</span> <span class="n">current_word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>



<span class="k">def</span> <span class="nf">find_words</span><span class="p">(</span><span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">current_word</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">find_words_dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">current_word</span><span class="p">)</span>


<span class="n">board</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;K&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">]</span>
<span class="p">]</span>
<span class="n">find_words</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Found: GEEKS
Found: QUIZ
</pre></div>
</div>
</div>
</div>
</section>
<section id="experiments">
<h2>Experiments<a class="headerlink" href="#experiments" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="c1">### DFS (Graph)</span>

<span class="c1"># An edge in an undirected connected graph is a bridge iff removing it disconnects the graph.</span>

<span class="c1">#   1     5       9</span>
<span class="c1">#   | \  /       / |</span>
<span class="c1">#   |  3 ------ 7  |</span>
<span class="c1">#   |/   \       \ |</span>
<span class="c1">#   2     4       8</span>
<span class="c1"># the bridges are [3-4], [3,5], and [3-7]</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bridges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># undirected graph, requires edge from u to v and from v to u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_directed_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">get_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">dfs_find_bridge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">anc</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">disc</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>

        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">anc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span>
        <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_time</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs_find_bridge</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">anc</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span>

                <span class="c1"># make sure earliest ancestor discoverable from w</span>
                <span class="c1"># is propagated to v&#39;s earliest ancestor if it&#39;s lower</span>
                <span class="n">anc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">anc</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">anc</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>


                <span class="c1"># if no subgraph of w has an earlier discovery time than v</span>
                <span class="c1"># then v-w is a bridge</span>
                <span class="k">if</span> <span class="n">anc</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bridges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">parents</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="c1"># since w is not v&#39;s parent,</span>
                <span class="c1"># make sure the earliest possible ancestor of v</span>
                <span class="c1"># incorporates the discovery time of w</span>
                <span class="n">anc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">anc</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">disc</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">find_bridges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Observations / Notes</span>
        <span class="c1"># Use DFS and if we&#39;ve visited a note previously</span>
        <span class="c1"># and there does not already exist a path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>

        <span class="c1"># start from each vertex in case the graph is disconnected</span>
        <span class="c1"># for v in self.graph.keys():</span>
        <span class="c1">#     if not visited[v]:</span>

        <span class="c1"># This works if the graph is not disconnected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs_find_bridge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The bridges in the graph are: &quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bridges</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bridges</span>

    <span class="k">def</span> <span class="nf">dfs_detect_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                         <span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                         <span class="n">parents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                         <span class="n">disc</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                         <span class="n">current_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

        <span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_time</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">found_cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs_detect_cycle</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">current_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">found_cycle</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">found_cycle</span>
            <span class="k">elif</span> <span class="n">parents</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">find_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span>


        <span class="n">starting_vertex</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">found_cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs_detect_cycle</span><span class="p">(</span><span class="n">starting_vertex</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">current_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">found_cycle</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found cycle visiting </span><span class="si">{</span><span class="n">starting_vertex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No cycle found.&quot;</span><span class="p">)</span>





<span class="c1">#   1     5       9</span>
<span class="c1">#   | \  /       / |</span>
<span class="c1">#   |  3 ------ 7  |</span>
<span class="c1">#   |/   \       \ |</span>
<span class="c1">#   2     4       8</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
    <span class="mi">2</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="mi">3</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span>
    <span class="mi">4</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span>
    <span class="mi">5</span><span class="p">:[</span><span class="mi">3</span><span class="p">],</span>
    <span class="mi">7</span><span class="p">:[</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
    <span class="mi">8</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>
    <span class="mi">9</span><span class="p">:[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">g</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
<span class="n">g</span><span class="o">.</span><span class="n">find_bridges</span><span class="p">()</span>
<span class="c1"># the bridges are [3-4], [3,5], and [3-7]</span>
<span class="nb">print</span><span class="p">()</span>



<span class="c1"># has cycle</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expecting cycle.&quot;</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">find_cycles</span><span class="p">()</span>
<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expecting no cycle.&quot;</span><span class="p">)</span>
<span class="c1"># no cycle</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_directed_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">find_cycles</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The bridges in the graph are: 
[[3, 4], [3, 5], [3, 7]]

Expecting cycle.
Found cycle visiting 1

Expecting no cycle.
No cycle found.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># topo sort</span>
<span class="c1"># requires that the graph is a DAG, directed acyclic graph</span>
<span class="c1"># topo sort is basically just printing the reverse of the postorder numbers of a DAG</span>
<span class="c1"># there are multiple valid topological sortings for a single DAG. This just depends on which neighbor is selected first during the DFS traversal</span>
<span class="c1"># Source: https://www.geeksforgeeks.org/topological-sorting/</span>
<span class="c1">#        4</span>
<span class="c1">#       /</span>
<span class="c1">#      1---5--7</span>
<span class="c1">#     / \</span>
<span class="c1">#    /   6</span>
<span class="c1">#   /</span>
<span class="c1">#  0 -- 2</span>
<span class="c1">#   \</span>
<span class="c1">#    3</span>
<span class="c1"># postorder: 4, 7, 5, 1, 6, 2, 3, 0</span>
<span class="c1"># reversed postorder: 0, 3, 2, 6, 1, 5, 7, 4</span>
<span class="n">dag</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span>
    <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span>
    <span class="mi">4</span><span class="p">:</span> <span class="p">[],</span>
    <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span>
    <span class="mi">6</span><span class="p">:</span> <span class="p">[],</span>
    <span class="mi">7</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>

<span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">visited</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>

    <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">dag</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>

    <span class="c1"># we visited v, so add it to the stack</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">topo_sort</span><span class="p">():</span>

    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dag</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">stack</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">topo_sort</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 3, 2, 1, 6, 5, 7, 4]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### How to detect a cycle with Union Find</span>

<span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># initially, the rank for each node is zero</span>
        <span class="c1"># since all nodes are separated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

        <span class="c1"># initially, all parents are the nodes themselves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># get the root of x</span>
        <span class="c1"># if x is not it&#39;s own parent, find it</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="c1"># otherwise, return x</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

        <span class="n">root_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">root_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_y</span>
            <span class="c1"># since we set y to be the parent of x,</span>
            <span class="c1"># if they had the same rank, increment y&#39;s rank now</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># basically keep joining vertices</span>
        <span class="c1"># based on adj list until we</span>
        <span class="c1"># find that two vertices have already been joined</span>
        <span class="c1"># (e.g. their roots are the same, find(x) == find(y))</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">neighbor</span><span class="p">):</span>
                    <span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cycle detected between </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">neighbor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>





<span class="c1">#   1             9</span>
<span class="c1">#   | \          / |</span>
<span class="c1">#   |  3 ------ 7  |</span>
<span class="c1">#   |/           \ |</span>
<span class="c1">#   2             8</span>
<span class="c1"># has cycle</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expecting two cycles&quot;</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">()</span>
<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expecting no cycle.&quot;</span><span class="p">)</span>
<span class="c1"># no cycle</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Expecting two cycles
cycle detected between 2 and 1
cycle detected between 9 and 7

Expecting no cycle.
</pre></div>
</div>
</div>
</div>
<section id="longest-increasing-path-in-a-matrix">
<h3>329. Longest Increasing Path in a Matrix<a class="headerlink" href="#longest-increasing-path-in-a-matrix" title="Permalink to this headline">¶</a></h3>
<p>Source: <a class="reference external" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">https://leetcode.com/problems/longest-increasing-path-in-a-matrix/</a></p>
<p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.</p>
<p>From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Longest increasing path</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestIncreasingPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="c1"># Observations, can use DFS, start traversal at each node, keep track of longest DFS</span>
        <span class="c1"># traversal</span>
        <span class="c1"># Need to reset visited before each DFS call</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


        <span class="k">def</span> <span class="nf">make_visited</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">add_to_tuple</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">tp</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tp</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">each</span> <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">tp</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">item</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">item</span><span class="p">,</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">prev</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">current_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">current_count</span>


            <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
                <span class="n">last_i</span><span class="p">,</span> <span class="n">last_j</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># if decreasing, stop</span>
                <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">last_i</span><span class="p">][</span><span class="n">last_j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">current_count</span>

                <span class="c1"># if i,j already in path</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">prev</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">current_count</span>

            <span class="n">current_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># run dfs on neighbors</span>
            <span class="n">cc_below</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">add_to_tuple</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">prev</span><span class="p">),</span> <span class="n">current_count</span><span class="o">=</span><span class="n">current_count</span><span class="p">)</span>
            <span class="n">cc_above</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">add_to_tuple</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">prev</span><span class="p">),</span> <span class="n">current_count</span><span class="o">=</span><span class="n">current_count</span><span class="p">)</span>
            <span class="n">cc_left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">add_to_tuple</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">prev</span><span class="p">),</span> <span class="n">current_count</span><span class="o">=</span><span class="n">current_count</span><span class="p">)</span>
            <span class="n">cc_right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">add_to_tuple</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">prev</span><span class="p">),</span> <span class="n">current_count</span><span class="o">=</span><span class="n">current_count</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">current_count</span><span class="p">,</span> <span class="n">cc_below</span><span class="p">,</span> <span class="n">cc_above</span><span class="p">,</span> <span class="n">cc_left</span><span class="p">,</span> <span class="n">cc_right</span><span class="p">)</span>

        <span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">longest_path_length</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">([]),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_count</span><span class="p">,</span> <span class="n">longest_path_length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_count</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DisjointSet</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

        <span class="n">root_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">root_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_y</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_x</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">root_y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># self.graph[v].append(u)  # if undirected</span>

    <span class="k">def</span> <span class="nf">has_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">DisjointSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="c1"># if they have the same parent, we&#39;ve found a cycle</span>
                <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">ds</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cycle detected between </span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ds</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="c1">#   1             9</span>
<span class="c1">#   | \          / |</span>
<span class="c1">#   |  3 ------ 7  |</span>
<span class="c1">#   |/           \ |</span>
<span class="c1">#   2             8</span>
<span class="c1"># has cycle</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expecting two cycles&quot;</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">()</span>
<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expecting no cycle.&quot;</span><span class="p">)</span>
<span class="c1"># no cycle</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">has_cycle</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Expecting two cycles
cycle detected between 2 and 1
cycle detected between 9 and 7

Expecting no cycle.
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Peter Lucia<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>